using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Jay.SourceGen.Code;
using Jay.SourceGen;

namespace Jay.EntityGen
{
    [Generator]
    public class EntityGenerator : IIncrementalGenerator
    {
        private static bool CouldBeEntityAttributeAsync(
            SyntaxNode syntaxNode,
            CancellationToken token)
        {
            if (syntaxNode is not AttributeSyntax attribute)
                return false;

            var name = ExtractName(attribute.Name);

            return name is Code.EntityAttribute.BaseName or
                Code.EntityAttribute.Name;
        }

        private static string? ExtractName(NameSyntax? name)
        {
            return name switch
            {
                SimpleNameSyntax ins => ins.Identifier.Text,
                QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                _ => null
            };
        }

        private static TypeDeclarationSyntax? GetTypeDeclarationOrNull(
            GeneratorSyntaxContext context,
            CancellationToken _)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // "attribute.Parent" is "AttributeListSyntax"
            Debug.Assert(attributeSyntax.Parent is AttributeListSyntax);

            // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
            var fragment = attributeSyntax.Parent?.Parent;

            if (fragment is TypeDeclarationSyntax typeDeclarationSyntax)
            {
                return typeDeclarationSyntax;
            }

            // Did not find a type declaration (weird?)
            return null;
        }

        internal static bool IsOurAttribute(ISymbol? typeSymbol)
        {
            if (typeSymbol is null) return false;
            var attributes = typeSymbol.GetAttributes();
            if (attributes.IsEmpty) return false;
            return attributes.Any(attr =>
            {
                var attrClass = attr.AttributeClass;
                if (attrClass is null) return false;
                if (attrClass.Name != Code.EntityAttribute.Name) return false;
                var ns = attrClass.ContainingNamespace;
                if (!ns.IsGlobalNamespace) return false;
                return true;
            });
        }


        private static void AddCodeSources(
            SourceProductionContext context,
            Compilation compilation,
            ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
        {
            if (typeDeclarations.IsDefaultOrEmpty) return;

            foreach (var typeDeclaration in typeDeclarations)
            {
                // Code!!!
                var (fullname, code) = GetCode(context, compilation, typeDeclaration);
                context.AddSource($"{fullname}.g.cs", code);
            }
        }

        internal sealed record class KeyMember(string Name, ITypeSymbol Type);

        private static (string FullName, string Code) GenerateCode(
            ITypeSymbol typeSymbol,
            List<KeyMember> keyMembers)
        {
            string? ns = typeSymbol.GetNamespace();
            string name = typeSymbol.Name;
            string varName = typeSymbol.GetVariableName();

            using var writer = new CodeWriter();
            writer
                .AutoGeneratedHeader()
                .Nullable(true)
                .NewLine()
                .Namespace(ns)
                .NewLine()
                .WriteLine($"partial class {name} : IEquatable<{name}>")
                .BracketBlock(classBlock =>
                {
                    classBlock.WriteLine($"public bool Equals({name}? {varName})")
                        .BracketBlock(methodBlock =>
                        {
                            methodBlock.Enumerate(keyMembers, (cw, keyMember) =>
                                {
                                    var memberName = keyMember.Name;
                                    var memberType = keyMember.Type.GetFQN();
                                    cw.WriteLine(
                                        $"if (!EqualityComparer<{memberType}>.Default.Equals(this.{memberName}, {varName}.{memberName})) return false;");
                                })
                                .WriteLine("return true;");
                        })
                        .NewLines(2)
                        .CodeBlock($$"""
                            public override bool Equals(object? obj)
                            {
                                return obj is {{name}} {{varName}} && Equals({{varName}});
                            }
                            """)
                        .NewLines(1)
                        .WriteLine("public override int GetHashCode()")
                        .BracketBlock(methodBlock =>
                        {
                            methodBlock.WriteLine("unchecked")
                                .BracketBlock(ub =>
                                {
                                    ub.WriteLine("int hash = 1009;")
                                        .Enumerate(keyMembers, static (cw, keyMember) =>
                                        {
                                            var memberName = keyMember.Name;
                                            if (keyMember.Type.CanBeNull())
                                            {
                                                cw.WriteLine(
                                                    $"hash = (hash * 9176) + (this.{memberName}?.GetHashCode() ?? 0);");
                                            }
                                            else
                                            {
                                                cw.WriteLine(
                                                    $"hash = (hash * 9176) + (this.{memberName}.GetHashCode());");
                                            }
                                        })
                                        .WriteLine("return hash;");
                                });
                        })
                        .NewLines(2)
                        .WriteLine("public override string ToString()")
                        .BracketBlock(methodBlock =>
                        {
                            methodBlock.Write($"return $\"{name}")
                                .Enumerate(keyMembers, static (cw, m) => cw.Write($" {m.Name}={{{m.Name}}}"))
                                .WriteLine("\";");
                        });
                });


            string code = writer.ToString();
            Debugger.Break();
            string fullname;
            if (!string.IsNullOrWhiteSpace(ns))
            {
                fullname = $"{ns}.{name}";
            }
            else
            {
                fullname = name;
            }
            return (fullname, code);
        }


        private static (string FullName, string Code) GetCode(SourceProductionContext context,
            Compilation compilation,
            TypeDeclarationSyntax typeDeclarationSyntax)
        {
            // Get the semantic representation of our marker attribute 
            INamedTypeSymbol? enumAttribute = compilation.GetTypeByMetadataName(Code.EntityAttribute.Name);


            // Get the semantic representation of the enum syntax
            SemanticModel semanticModel = compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree);
            INamedTypeSymbol typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclarationSyntax)!;
            if (typeSymbol is null) throw new InvalidOperationException();

            // Get all the members in the enum
            ImmutableArray<ISymbol> typeMembers = typeSymbol.GetMembers();

            // Get all of them that have the Key attribute
            var keyMembers = new List<KeyMember>();

            // Scan for instances of our Key attribute
            foreach (ISymbol member in typeMembers)
            {
                ImmutableArray<AttributeData> attributes;
                ITypeSymbol memberType;

                if (member is IPropertySymbol property)
                {
                    attributes = property.GetAttributes();
                    memberType = property.Type;
                }
                else if (member is IFieldSymbol field)
                {
                    attributes = field.GetAttributes();
                    memberType = field.Type;
                }
                else
                {
                    continue;
                }

                if (attributes.Any(attr =>
                    {
                        var attrClass = attr.AttributeClass;
                        if (attrClass is null) return false;
                        string attrName = attrClass.Name;
                        if (!string.Equals(attrName, Code.KeyAttribute.Name) &&
                            !string.Equals(attrName, Code.KeyAttribute.BaseName)) return false;

                        //var attrMembers = attrClass.GetMembers();
                        //Debugger.Break();
                        return true;
                    }))
                {
                    keyMembers.Add(new(member.Name, memberType));
                }
            }

            return GenerateCode(typeSymbol, keyMembers);
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
#if DEBUG && ATTACH
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif

            // Add our main Attribute
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource($"{Code.EntityAttribute.Name}.g.cs",
                    SourceText.From(Code.EntityAttribute.Code, Encoding.UTF8));

                ctx.AddSource($"{Code.KeyAttribute.Name}.g.cs",
                    SourceText.From(Code.KeyAttribute.Code, Encoding.UTF8));
            });

            // IncrementalValueProvider<ImmutableArray<ITypeSymbol>> enumTypes = context
            //     .SyntaxProvider
            //     .CreateSyntaxProvider(CouldBeEntityAttributeAsync, GetEnumTypeOrNull)
            //     .Where(type => type is not null)
            //     .Collect()!;

            // var typesProvider = context
            //     .SyntaxProvider
            //     .CreateSyntaxProvider(CouldBeEntityAttributeAsync, GetEnumTypeOrNull)
            //     .Where(type => type is not null)
            //     .Combine(context.CompilationProvider)
            //     .WithComparer(new IdentifierAndCompilationComparer())
            //
            // context.RegisterSourceOutput(enumTypes, GenerateCode);

            // First pass simple filter
            IncrementalValuesProvider<TypeDeclarationSyntax> enumDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    // select all of our attribute
                    predicate: static (s, t) => CouldBeEntityAttributeAsync(s, t),
                    // get the type they are declared upon
                    transform: static (ctx, t) => GetTypeDeclarationOrNull(ctx, t))
                // Cleanup
                .Where(static m => m is not null)!;

            // Combine the selected enums with the `Compilation`
            IncrementalValueProvider<(ImmutableArray<TypeDeclarationSyntax>, Compilation)> combined =
                enumDeclarations
                    .Collect()
                    .Combine(context.CompilationProvider)
                    .WithComparer(new Filter());

            // Generate the output source
            context.RegisterSourceOutput(combined,
                static (spc, src) => AddCodeSources(spc, src.Item2, src.Item1));
        }
    }
}


internal sealed class Filter : IEqualityComparer<(
    ImmutableArray<TypeDeclarationSyntax>, Compilation)>
{
    public bool Equals(
        (ImmutableArray<TypeDeclarationSyntax>, Compilation) x,
        (ImmutableArray<TypeDeclarationSyntax>, Compilation) y)
    {
        return x.Item1.SequenceEqual(y.Item1, static (xDec, yDec) => Compare(xDec, yDec));
    }

    private static bool Compare(
        TypeDeclarationSyntax arg1,
        TypeDeclarationSyntax arg2)
    {
        return string.Equals(arg1.Identifier.Text, arg2.Identifier.Text);
    }

    public int GetHashCode((ImmutableArray<TypeDeclarationSyntax>, Compilation) obj)
    {
        unchecked
        {
            int hash = 1009; // seed
            var array = obj.Item1;
            for (var i = 0; i < array.Length; i++)
            {
                var itemHash = array[i].Identifier.Text.GetHashCode();
                hash = (hash * 9176 /* factor */) + itemHash;
            }

            return hash;
        }
    }
}