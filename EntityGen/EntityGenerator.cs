using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Text;

using Jay.SourceGen.Code;

using static Jay.SourceGen.EntityGen.EntityGenerator;

namespace Jay.SourceGen.EntityGen;

[Generator]
public class EntityGenerator : IIncrementalGenerator
{
    private static bool CouldBeEntityAttributeAsync(SyntaxNode syntaxNode, CancellationToken _)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        return name is Code.EntityAttribute.BaseName or
            Code.EntityAttribute.Name;
    }

    private static string? ExtractName(NameSyntax? name)
    {
        return name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }

    private static TypeDeclarationSyntax? GetTypeDeclarationOrNull(GeneratorSyntaxContext context,
        CancellationToken _)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        Debug.Assert(attributeSyntax.Parent is AttributeListSyntax);

        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        var fragment = attributeSyntax.Parent?.Parent;

        if (fragment is TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return typeDeclarationSyntax;
        }

        // Did not find a type declaration (weird?)
        return null;
    }

    internal static bool IsOurAttribute(ISymbol? typeSymbol)
    {
        if (typeSymbol is null) return false;
        var attributes = typeSymbol.GetAttributes();
        if (attributes.IsEmpty) return false;
        return attributes.Any(attr =>
        {
            var attrClass = attr.AttributeClass;
            if (attrClass is null) return false;
            if (attrClass.Name != Code.EntityAttribute.Name) return false;
            var ns = attrClass.ContainingNamespace;
            if (!ns.IsGlobalNamespace) return false;
            return true;
        });
    }


    private static void AddCodeSources(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
    {
        if (typeDeclarations.IsDefaultOrEmpty) return;

        foreach (var typeDeclaration in typeDeclarations)
        {
            // Code!!!
            foreach (var codePart in GetCodeParts(context, compilation, typeDeclaration))
            {
                context.AddSource($"{codePart.FullName}.g.cs",
                    SourceText.From(codePart.Code, Encoding.UTF8));
            }
        }
    }

    internal sealed class EntityInfo
    {
        public ITypeSymbol Type { get; }
        public List<KeyMember> Members { get; }
        public bool Nullability { get; }

        public string? NameSpace => Type.GetNamespace();
        public string Name => Type.Name;
        public string VarName => Type.GetVariableName();

        public EntityInfo(ITypeSymbol type, List<KeyMember> keyMembers, bool nullability)
        {
            Type = type;
            Members = keyMembers;
            Nullability = nullability;
        }
    }

    internal sealed record class KeyMember(string Name, ITypeSymbol Type, bool Equality, bool Comparison, bool Display);

        private static (string FileName, string Code) CreateDisplayPart(EntityInfo entityInfo)
    {
        using var writer = new CodeWriter();

        string entityType = entityInfo.Name;
        string varName = entityInfo.VarName;

        var displayMembers = entityInfo.Members.Where(km => km.Display).ToList();

        writer.AutoGeneratedHeader()
            .Nullable(entityInfo.Nullability)
            .NewLine()
            .Using("System.Collections.Generic")
            .NewLine()
            .Namespace(entityInfo.NameSpace)
            .NewLine()
            .CodeBlock($$"""
                partial class {{entityType}} : IFormattable
                {
                    public string ToString(string? format, IFormatProvider? provider = null)
                    {
                        return $"{{entityType}} {{"{{"}} {{(CWA)(w => w.EnumerateDelimit(", ", displayMembers,
                        (cw, km) => cw.Write($"{km.Name} = {{{km.Name}:{{format}}}}")))}} {{"}}"}}";
                    }

                    public override string ToString()
                    {
                        return $"{{entityType}} {{"{{"}} {{(CWA)(w => w.EnumerateDelimit(", ", displayMembers,
                        (cw, km) => cw.Write($"{km.Name} = {{{km.Name}}}")))}} {{"}}"}}";
                    }
                }
                """);

        string code = writer.ToString();
        return ($"{entityInfo.Type.GetFQN()}.Equatable", code);
    }

    private static (string FileName, string Code) CreateEquatablePart(EntityInfo entityInfo)
    {
        using var writer = new CodeWriter();

        string entityType = entityInfo.Name;
        string varName = entityInfo.VarName;

        var eqMembers = entityInfo.Members.Where(km => km.Equality).ToList();

        writer.AutoGeneratedHeader()
            .Nullable(entityInfo.Nullability)
            .NewLine()
            .Using("System.Collections.Generic")
            .NewLine()
            .Namespace(entityInfo.NameSpace)
            .NewLine()
            .CodeBlock($$"""
                partial class {{entityType}} : IEquatable<{{entityType}}>
                {
                    public static bool operator ==({{entityType}}? left, {{entityType}}? right)
                    {
                        if (ReferenceEquals(left, right)) return true;
                        if (left is null || right is null) return false;
                        return left.Equals(right);
                    }                            

                    public static bool operator !=({{entityType}}? left, {{entityType}}? right)
                    {
                        if (ReferenceEquals(left, right)) return false;
                        if (left is null || right is null) return true;
                        return !left.Equals(right);
                    }


                    public bool Equals({{entityType}}? {{varName}})
                    {
                        if ({{varName}} is null) return false;
                        {{(CWA)(w => w.EnumerateLines(eqMembers,
                            (cw, km) => cw.Write(
                            $"if (!EqualityComparer<{km.Type}>.Default.Equals(this.{km.Name}, {varName}.{km.Name})) return false;"))
                        )}}
                        return true;
                    }


                    public override bool Equals(object? obj)
                    {
                        return obj is {{entityType}} {{varName}} && Equals({{varName}});
                    }

                    public override int GetHashCode()
                    {
                        unchecked
                        {
                            int hash = 1009;
                            {{(CWA)(w => w.EnumerateLines(eqMembers, (cw, km) =>
                            {
                                cw.Write($"hash = (hash * 9176) + ");
                                if (km.Type.CanBeNull())
                                    cw.Write($"({km.Name}?.GetHashCode() ?? 0);");
                                else
                                    cw.Write($"{km.Name}.GetHashCode();");
                            }))}}
                            return hash;
                        }
                    }
                }
                """);

        string code = writer.ToString();
        return ($"{entityInfo.Type.GetFQN()}.Equatable", code);
    }

    private static (string FileName, string Code) CreateComparablePart(EntityInfo entityInfo)
    {
        using var writer = new CodeWriter();

        string entityType = entityInfo.Name;
        string varName = entityInfo.VarName;
        var keyMembers = entityInfo.Members;

        var compareMember = keyMembers.Single(m => m.Comparison);
        var memberName = compareMember.Name;
        var memberType = compareMember.Type;

        writer.AutoGeneratedHeader()
            .Nullable(entityInfo.Nullability)
            .NewLine()
            .Using("System.Collections.Generic")
            .NewLine()
            .Namespace(entityInfo.NameSpace)
            .NewLine()
            .CodeBlock($$"""
                partial class {{entityType}} : IComparable<{{entityType}}>
                {
                    public static bool operator <({{entityType}} left, {{entityType}} right) => 
                        Comparer<{{memberType}}>.Default.Compare(left.{{memberName}}, right.{{memberName}}) < 0;
                
                    public static bool operator <=({{entityType}} left, {{entityType}} right) => 
                        Comparer<{{memberType}}>.Default.Compare(left.{{memberName}}, right.{{memberName}}) <= 0;
                    
                    public static bool operator >({{entityType}} left, {{entityType}} right) => 
                        Comparer<{{memberType}}>.Default.Compare(left.{{memberName}}, right.{{memberName}}) > 0;
                    
                    public static bool operator >=({{entityType}} left, {{entityType}} right) => 
                        Comparer<{{memberType}}>.Default.Compare(left.{{memberName}}, right.{{memberName}}) >= 0;
                    
                    
                    public int CompareTo({{entityType}}? {{varName}})
                    {
                        // Nulls sort first
                        if ({{varName}} == null) return 1;
                        return Comparer<{{memberType}}>.Default.Compare(this.{{memberName}}, {{varName}}.{{memberName}});
                    }
                }
                """);

        string code = writer.ToString();
        return ($"{entityInfo.Type.GetFQN()}.Comparable", code);
    }

    private static IEnumerable<(string FullName, string Code)> GetCodeParts(
        SourceProductionContext context,
        Compilation compilation,
        TypeDeclarationSyntax typeDeclarationSyntax)
    {
        //  Get the semantic representation of the enum syntax
        SemanticModel semanticModel = compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree);
        INamedTypeSymbol typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclarationSyntax)!;
        if (typeSymbol is null) throw new InvalidOperationException();

        // Get all the members
        ImmutableArray<ISymbol> typeMembers = typeSymbol.GetMembers();

        // Get all of them that have the Key attribute
        var members = new List<KeyMember>();

        // Scan for instances of our Key attribute
        foreach (ISymbol member in typeMembers)
        {
            ImmutableArray<AttributeData> attributes;
            ITypeSymbol memberType;

            if (member is IPropertySymbol property)
            {
                attributes = property.GetAttributes();
                memberType = property.Type;
            }
            else if (member is IFieldSymbol field)
            {
                attributes = field.GetAttributes();
                memberType = field.Type;
            }
            else
            {
                continue;
            }

            var equalityAttr = attributes.FirstOrDefault(attr =>
            {
                string? attrName = attr.AttributeClass?.Name;
                return attrName is Code.PropertyAttributes.EqualityName or Code.PropertyAttributes.EqualityNameShort;
            });

            var comparisonAttr = attributes.FirstOrDefault(attr =>
            {
                string? attrName = attr.AttributeClass?.Name;
                return attrName is Code.PropertyAttributes.ComparisonName or Code.PropertyAttributes.ComparisonNameShort;
            });

            var displayAttr = attributes.FirstOrDefault(attr =>
          {
              string? attrName = attr.AttributeClass?.Name;
              return attrName is Code.PropertyAttributes.DisplayName or Code.PropertyAttributes.DisplayNameShort;
          });

            var keyAttr = attributes.FirstOrDefault(attr =>
        {
            string? attrName = attr.AttributeClass?.Name;
            return attrName is Code.PropertyAttributes.KeyName or Code.PropertyAttributes.KeyNameShort;
        });

            members.Add(new(member.Name,
                memberType,
                keyAttr is not null || equalityAttr is not null,
                keyAttr is not null || comparisonAttr is not null,
                keyAttr is not null || displayAttr is not null));
        }

        var entityInfo = new EntityInfo(typeSymbol, members, true);

        yield return CreateEquatablePart(entityInfo);

        if (members.Count(m => m.Comparison) == 1)
        {
            yield return CreateComparablePart(entityInfo);
        }

        yield return CreateDisplayPart(entityInfo);
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG && ATTACH
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif

        // Add our main Attribute
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource($"{Code.EntityAttribute.Name}.g.cs",
                SourceText.From(Code.EntityAttribute.Code, Encoding.UTF8));

            ctx.AddSource($"EntityPropAttributes.g.cs",
                SourceText.From(Code.PropertyAttributes.Code, Encoding.UTF8));
        });

        // First pass simple filter
        IncrementalValuesProvider<TypeDeclarationSyntax> enumDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                // select all of our attribute
                predicate: static (s, t) => CouldBeEntityAttributeAsync(s, t),
                // get the type they are declared upon
                transform: static (ctx, t) => GetTypeDeclarationOrNull(ctx, t))
            // Cleanup
            .Where(static m => m is not null)!;

        // Combine the selected enums with the `Compilation`
        IncrementalValueProvider<(ImmutableArray<TypeDeclarationSyntax>, Compilation)> combined =
            enumDeclarations
                .Collect()
                .Combine(context.CompilationProvider)
                .WithComparer(new Filter());

        // Generate the output source
        context.RegisterSourceOutput(combined,
            static (spc, src) => AddCodeSources(spc, src.Item2, src.Item1));
    }
}


internal sealed class Filter : IEqualityComparer<(
    ImmutableArray<TypeDeclarationSyntax>, Compilation)>
{
    public bool Equals(
        (ImmutableArray<TypeDeclarationSyntax>, Compilation) x,
        (ImmutableArray<TypeDeclarationSyntax>, Compilation) y)
    {
        return x.Item1.SequenceEqual(y.Item1, static (xDec, yDec) => Compare(xDec, yDec));
    }

    private static bool Compare(
        TypeDeclarationSyntax arg1,
        TypeDeclarationSyntax arg2)
    {
        return string.Equals(arg1.Identifier.Text, arg2.Identifier.Text);
    }

    public int GetHashCode((ImmutableArray<TypeDeclarationSyntax>, Compilation) obj)
    {
        return Hasher.GetHashCode(obj.Item1.Select(a => a.Identifier.Text));
    }
}