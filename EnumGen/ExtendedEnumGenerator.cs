using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Jay.SourceGen;
using Jay.SourceGen.Code;
using Jay.SourceGen.Text;

namespace Jay.EnumGen;




[Generator]
public class ExtendedEnumGenerator : IIncrementalGenerator
{
    internal readonly struct EnumInfo
    {
        public readonly string Namespace;
        public readonly string FQN;
        public readonly string Name;
        public readonly bool HasFlags;
        public readonly List<string> Members;

        public EnumInfo(string ns, string fqn, string name, bool hasFlags, List<string> members)
        {
            Namespace = ns;
            FQN = fqn;
            Name = name;
            HasFlags = hasFlags;
            Members = members;
        }
    }

    private static string GetEnumVariableName(EnumInfo enumInfo)
    {
        var name = enumInfo.Name.WithNaming(Naming.Camel);
        if (SyntaxFacts.IsValidIdentifier(name) || name.StartsWith("flag"))
        {
            return "value";
        }
        return name;
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ITypeSymbol> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty)
            return;

        foreach (var type in enumerations)
        {
            var code = GenerateCode(type);
            var typeNamespace = type.GetNamespace();

            context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
        }
    }

    private static IEnumerable<string> GetMemberNames(ITypeSymbol type)
    {
        var members = type.GetMembers()
            .Where(member =>
            {
                if (member is null) return false;
                if (!member.IsStatic) return false;
                if (member.DeclaredAccessibility != Accessibility.Public) return false;
                if (member is not IFieldSymbol field) return false;
                return SymbolEqualityComparer.Default.Equals(field.Type, type);
            })
            .Select(symbol => symbol.Name);
        return members;
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        var name = type.Name;
        var ns = type.GetNamespace();

        var items = GetMemberNames(type);

        var writer = new CodeWriter();
        writer.WriteAutoGeneratedHeader()
            .Using("System.Numerics")
            // Usings?
            .Namespace(ns)
            .NewLine()
            .Parse($"""
                public readonly partial struct {name} : 
                    IEqualityOperators<{name},{name},bool>, IEquatable<{name}>,
                    IComparison

                    """)
            .BracketBlock(structBlock =>
            {
                structBlock.Parse($$"""
                    private static readonly {{name}}[] _members;

                    public static IReadOnlyList<{{name}}> Members => _members;


                    """)
            });


        return @$"
   partial class {name}
   {{
      private static IReadOnlyList<{name}> _items;
      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      private static IReadOnlyList<{name}> GetItems()
      {{
         return new[] {{ {String.Join(", ", items)} }};
      }}
   }}
{(ns is null ? null : @"}
";
    }




    private static void Extend(Compilation compilation,
        ImmutableArray<ITypeSymbol> types,
        SourceProductionContext context)
    {
        // Do we have any to create?
        if (types.IsDefaultOrEmpty) return;

        // Cleanup?
        IEnumerable<StructDeclarationSyntax> enums = types.Distinct();



        var enumInfos = GetEnumInfos(compilation, enums, context.CancellationToken);
        if (enumInfos.Count > 0)
        {
            foreach (var enumInfo in enumInfos)
            {
                using var writer = new CodeWriter();
                WriteExtensions(writer, enumInfo, methodWriter =>
                {
                    AddExtensionMethods(methodWriter, enumInfo);

                    if (enumInfo.HasFlags)
                    {
                        AddFlagsExtensionsMethods(methodWriter, enumInfo);
                    }
                });
                var code = writer.ToString();
                if (Debugger.IsAttached)
                {
                    Debugger.Break();
                }
                context.AddSource($"{enumInfo.Name}Extensions.g.cs", 
                    SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    private static List<EnumInfo> GetEnumInfos(Compilation compilation,
        IEnumerable<EnumDeclarationSyntax> enumDeclarations,
        CancellationToken token)
    {
        var enumInfos = new List<EnumInfo>();

        // We're interested in [Flags]
        INamedTypeSymbol? systemFlagsAttribute = compilation.GetTypeByMetadataName("System.FlagsAttribute");

        // Process all enum declarations
        foreach (var enumDeclaration in enumDeclarations)
        {
            token.ThrowIfCancellationRequested();

            SemanticModel semanticModel = compilation.GetSemanticModel(enumDeclaration.SyntaxTree);
            if (ModelExtensions.GetDeclaredSymbol(semanticModel, enumDeclaration) is not INamedTypeSymbol enumSymbol)
            {
                Debug.WriteLine("Could not find EnumDeclaration as a NamedTypeSymbol in semanticModel");
                continue;
            }

            string enumName = enumSymbol.Name;
            string enumNamespace = enumSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : enumSymbol.ContainingNamespace.ToString();
            var ns = Jay.SourceGen.Extensions.GetNamespace(enumDeclaration);
            Debug.Assert(ns == enumNamespace);
            var hasFlags = false;

            // Check this enum's attributes for [Flags]
            foreach (AttributeData attributeData in enumSymbol.GetAttributes())
            {
                // If this is [Flags], record it
                if (SymbolEqualityComparer.Default.Equals(systemFlagsAttribute, attributeData.AttributeClass))
                {
                    hasFlags = true;
                    break;
                }
            }

            string fullyQualifiedName = enumSymbol.ToString();
            //string underlyingType = enumSymbol.EnumUnderlyingType?.ToString() ?? "int";

            var enumMembers = enumSymbol.GetMembers();
            var memberNames = new List<string>(enumMembers.Length);

            foreach (var member in enumMembers)
            {
                // Has to be a constant field (aka an enum member)
                if (member is not IFieldSymbol field || field.ConstantValue is null)
                {
                    continue;
                }

                string memberName = field.Name;
                memberNames.Add(memberName);
            }

            enumInfos.Add(new EnumInfo(enumNamespace, fullyQualifiedName, enumName, hasFlags, memberNames));
        }

        return enumInfos;
    }


    private static StructDeclarationSyntax? GetStructDeclarationForGeneration(GeneratorSyntaxContext context, CancellationToken token)
    {
        // we know the node is a StructDeclarationSyntax thanks to IsSyntaxTargetForGeneration
        var structDeclarationSyntax = (StructDeclarationSyntax)context.Node;

        // loop through all the attributes on the method
        foreach (AttributeListSyntax attributeListSyntax in structDeclarationSyntax.AttributeLists)
        {
            if (token.IsCancellationRequested) return null;

            foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    // weird, we couldn't get the symbol, ignore it
                    continue;
                }

                INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                string fullName = attributeContainingTypeSymbol.ToDisplayString();

                // Is the attribute the one we're looking for?
                if (fullName == $"Jay.EnumGen.{Code.AttributeName}")
                {
                    // Has to be readonly
                    var isReadOnly = structDeclarationSyntax.Modifiers.Any(mod => mod.IsKind(SyntaxKind.ReadOnlyKeyword));
                    if (!isReadOnly)
                        throw new Exception("Not readonly");

                    // return the enum
                    return structDeclarationSyntax;
                }
            }
        }

        // we didn't find the attribute we were looking for
        return null;
    }   




    private static bool CouldBeAttribute(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        return name == Code.AttributeName;
    }

    private static string? ExtractName(NameSyntax? name)
    {
        return name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }


    private static ITypeSymbol? GetExtendableTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken token)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not StructDeclarationSyntax str)
        {
            throw new InvalidOperationException();
            return null;
        }

        var type = context.SemanticModel.GetDeclaredSymbol(str, token) as ITypeSymbol;

        return type is null || !IsEnumeration(type) ? null : type;
    }

    private static bool IsEnumeration(ISymbol type)
    {
        return type.GetAttributes()
            .Any(a => a.AttributeClass?.Name == Code.AttributeName &&
                a.AttributeClass.ContainingNamespace is
                {
                    Name: "Jay.EnumGen",
                    ContainingNamespace.IsGlobalNamespace: true
                });
    }


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add raw code
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource($"{Code.AttributeName}.g.cs",
                 SourceText.From(Code.AttributeCode, Encoding.UTF8));
        });

        // All struct declarations with at least one attribute
        IncrementalValuesProvider<ITypeSymbol> structDeclarations
            = context.SyntaxProvider.CreateSyntaxProvider(
                //predicate: static (node, token) => node is StructDeclarationSyntax { AttributeLists.Count: > 0 },
                //transform: static (ctx, token) => GetStructDeclarationForGeneration(ctx, token)
                predicate: static (node, token) => CouldBeAttribute(node, token),
                transform: static (ctx, token) => GetExtendableTypeOrNull(ctx, token)
            ).Where(static stx => stx is not null)!;


        var collect = structDeclarations.Collect();
        context.RegisterSourceOutput(collect, GenerateCode);
    }
}