

using System.Text;
using Jay.SourceGen;
using Jay.SourceGen.Code;
using Jay.SourceGen.Text;

internal static class Code
{
    public const string AttributeName = "AsEnum";
    public const string AttributeFullName = "AsEnumAttribute";
    public const string AttributeCode = $$"""
        // <auto-generated/>
                
        [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false, Inherited = true)]
        public sealed class {{AttributeFullName}} : Attribute
        {
            public bool Flags { get; set; } = false;
            public Type UnderlyingType { get; set; } = typeof(int);

            public {{AttributeFullName}}()
            {
        
            }
        }
        """;
}

[Generator]
public class ExtendGenerator : IIncrementalGenerator
{
    private const string IdFieldName = "__id";


    private static bool IsAttribute(SyntaxNode syntaxNode, CancellationToken _)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = attribute.Name.ExtractName();

        return name is Code.AttributeName or Code.AttributeFullName;
    }

    private static ExtendStructInfo GetExtendStructInfo(GeneratorSyntaxContext context, CancellationToken token)
    {
        throw new NotImplementedException();
    }

    private static void WriteOperators(CodeWriter writer, ExtendStructInfo extendStructInfo)
    {
        var typeName = extendStructInfo.TypeName;
        var varName = extendStructInfo.VariableName;
        writer.Parse($"""
        public static bool operator ==({typeName} left, {typeName} right) => left.{IdFieldName} == right.{IdFieldName};
        public static bool operator !=({typeName} left, {typeName} right) => left.{IdFieldName} != right.{IdFieldName};
        public static bool operator >({typeName} left, {typeName} right) => left.{IdFieldName} > right.{IdFieldName};
        public static bool operator >=({typeName} left, {typeName} right) => left.{IdFieldName} >= right.{IdFieldName};
        public static bool operator <({typeName} left, {typeName} right) => left.{IdFieldName} < right.{IdFieldName};
        public static bool operator <=({typeName} left, {typeName} right) => left.{IdFieldName} <= right.{IdFieldName};

        public static explicit operator {typeName}({extendStructInfo.UnderlyingType} value) => Parse(value); 
        public static explicit operator {extendStructInfo.UnderlyingType}({typeName} {varName}) => {varName}.{IdFieldName}; 
        """);
    }

    private static void WriteStaticBacking(CodeWriter writer, ExtendStructInfo extendStructInfo)
    {
        var typeName = extendStructInfo.TypeName;

        writer.WriteLine($"private static readonly {typeName}[] _members;")
            .WriteLine("private static readonly string[] _memberNames;")
            .NewLine()
            .WriteLine($"static {typeName}()")
            .BracketBlock(staticCtorBlock =>
            {

            })
            .NewLine()
            .WriteLine($"public static {typeName}[] Members => _members;")

    }

    private static void Generate(SourceProductionContext ctx, ExtendStructInfo extendInfo)
    {
        using var writer = new CodeWriter();
        var name = extendInfo.TypeName;

        writer.WriteAutoGeneratedHeader()
            //.Using()
            .Namespace(extendInfo.Namespace)
            .NewLine()
            .WriteLine($"{extendInfo.Access.ToCode()} readonly partial struct {name} : ")
            .IndentBlock(implementBlock => implementBlock.Parse(
                $"""
                 IEqualityOperators<{name},{name},bool>, IEquatable<{name}>,
                 IComparisonOperators<{name},{name},bool>, IComparable<{name}>,
                 ISpanParsable<{name}>, IParsable<{name}>,
                 ISpanFormattable, IFormattable
                 """))
            .BracketBlock(structBlock =>
            {
                WriteOperators(structBlock, extendInfo);
                WriteStaticBacking(structBlock, extendInfo);
            });




        var sourceCode = writer.ToString();
        ctx.AddSource($"{extendInfo.FQN}.g.cs",
            SourceText.From(sourceCode, Encoding.UTF8));
    }



    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource($"{Code.AttributeFullName}.g.cs",
                SourceText.From(Code.AttributeCode, Encoding.UTF8));
        });
        
        var classProvider = context.SyntaxProvider
                .CreateSyntaxProvider(), GetExtendStructInfo)
            .Collect()
            .SelectMany((myObjects, _) => myObjects.Distinct());

        context.RegisterSourceOutput(classProvider, Generate);
    }
}

public readonly struct ExtendStructMemberInfo : IEquatable<ExtendStructMemberInfo>
{

}

public readonly struct ExtendStructInfo : IEquatable<ExtendStructInfo>
{
    public readonly string FQN;
    public readonly string? Namespace;
    public readonly Accessibility Access;
    public readonly string TypeName;
    public readonly ITypeSymbol? UnderlyingType;
    public readonly List<ExtendStructMemberInfo> Members;

    public string VariableName
    {
        get
        {
            var name = this.TypeName.WithNaming(Naming.Camel);
            if (SyntaxFacts.IsValidIdentifier(name))
            {
                return "value";
            }
            return name;
        }
    }

    public bool Equals(ExtendStructInfo other)
    {
        return string.Equals(FQN, other.FQN);
    }

    public override bool Equals(object? obj)
    {
        return obj is ExtendStructInfo other && Equals(other);
    }

    public override int GetHashCode()
    {
        return FQN.GetHashCode();
    }

    public override string ToString()
    {
        return $"{Namespace} {Access} {TypeName}";
    }
}
