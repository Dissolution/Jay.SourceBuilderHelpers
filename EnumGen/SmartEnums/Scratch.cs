/*using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Jay.SourceGen;
using Jay.SourceGen.Code;
using Jay.SourceGen.Text;

internal static class Code
{
    public const string AttributeName = "AsEnum";
    public const string AttributeFullName = "AsEnumAttribute";

    public const string AttributeCode = $$"""
        // <auto-generated/>
                
        [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false, Inherited = true)]
        public sealed class {{AttributeFullName}} : Attribute
        {
            public bool Flags { get; set; } = false;
            public Type UnderlyingType { get; set; } = typeof(int);

            public {{AttributeFullName}}()
            {
        
            }
        }
        """;
}

[Generator]
public class ExtendGenerator : IIncrementalGenerator
{
    private const string IdFieldName = "__id";


    private static bool IsAttribute(
        SyntaxNode syntaxNode, 
        CancellationToken _)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = attribute.Name.ExtractName();

        return name is Code.AttributeName or Code.AttributeFullName;
    }

    private static StructDeclarationSyntax GetStructDeclaration(
        GeneratorSyntaxContext context,
        CancellationToken token)
    {
        AttributeSyntax attribute = (context.Node as AttributeSyntax)!;
        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attribute.Parent?.Parent is not StructDeclarationSyntax structDeclaration)
            throw new Exception("Attribute must be on readonly struct def");
        return structDeclaration;
    }

    private static ExtendStructInfo GetExtendStructInfo(GeneratorSyntaxContext context, CancellationToken token)
    {
        string fqn;
        string? ns;
        Accessibility access;
        string typeName;
        ITypeSymbol? underlyingType;
        List<ExtendStructMemberInfo> members = new();

        AttributeSyntax attribute = (context.Node as AttributeSyntax)!;

        var attributeType = context.SemanticModel.GetTypeInfo(attribute, token);
        var mem2 = attributeType.Type.GetMembers();


        var argList = attribute.ArgumentList;

        var children = attribute.ChildNodes();

        var symbol = context.SemanticModel.GetSymbolInfo(attribute, token);

        SemanticModel semanticModel = context.GetSemanticModel(receiverMigrationFunctionAttribute.SyntaxTree);

        foreach (var attributeArgumentSyntax in receiverMigrationFunctionAttribute.ArgumentList.Arguments)
        {
        }

        Debugger.Break();


        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attribute.Parent?.Parent is not StructDeclarationSyntax structDeclaration)
            throw new Exception("Attribute must be on readonly struct def");

        var isReadOnly = structDeclaration.Modifiers.Any(SyntaxKind.ReadOnlyKeyword);
        if (!isReadOnly)
            throw new Exception("Attribute must be on readonly struct def");


        var type = context.SemanticModel.GetDeclaredSymbol(structDeclaration, token) as ITypeSymbol;

        if (type is null)
            throw new InvalidOperationException();

        fqn = type.ToString();
        ns = type.GetNamespace();
        access = type.DeclaredAccessibility;
        typeName = type.Name;
        underlyingType = default;


        return new ExtendStructInfo(fqn, ns, access, typeName, underlyingType, members);
    }

    private static void WriteOperators(CodeWriter writer, ExtendStructInfo extendStructInfo)
    {
        var typeName = extendStructInfo.TypeName;
        var varName = extendStructInfo.VariableName;
        writer.CodeBlock($"""
        public static bool operator ==({typeName} left, {typeName} right) => left.{IdFieldName} == right.{IdFieldName};
        public static bool operator !=({typeName} left, {typeName} right) => left.{IdFieldName} != right.{IdFieldName};
        public static bool operator >({typeName} left, {typeName} right) => left.{IdFieldName} > right.{IdFieldName};
        public static bool operator >=({typeName} left, {typeName} right) => left.{IdFieldName} >= right.{IdFieldName};
        public static bool operator <({typeName} left, {typeName} right) => left.{IdFieldName} < right.{IdFieldName};
        public static bool operator <=({typeName} left, {typeName} right) => left.{IdFieldName} <= right.{IdFieldName};

        public static explicit operator {typeName}({extendStructInfo.UnderlyingType} value) => Parse(value); 
        public static explicit operator {extendStructInfo.UnderlyingType}({typeName} {varName}) => {varName}.{IdFieldName}; 
        """);
    }

    private static void WriteStaticBacking(CodeWriter writer, ExtendStructInfo structInfo)
    {
        var typeName = structInfo.TypeName;
        var varName = structInfo.VariableName;

        // fields
        writer.CodeBlock($$"""
            private static readonly {{typeName}}[] _members;
            private static readonly string[] _memberNames;

            static {{typeName}}()
            {
            }

            public static {{typeName}}[] Members => _members;
            public static string[] MemberNames => _memberNames;
                    
            public static {{typeName}} Parse({{structInfo.UnderlyingType}} value)
            {
                {{(CWA)(w =>
                {
                    foreach (var member in structInfo.Members)
                    {
                        w.CodeBlock($"if (value == {member.Id}) return {member.Name};");
                    }
                })}}
                throw new ArgumentException($"Could not parse '{value}' to a {{typeName}} value", nameof(value));
            }
            
            public static bool TryParse({{structInfo.UnderlyingType}} value, [MaybeNullWhen(false)] out {{typeName}} {{varName}})
            {
                {{(CWA)(w =>
                {
                    // Check values
                    foreach (var member in structInfo.Members)
                    {
                        w.CodeBlock($$"""
                            if (value == {{member.Id}})
                            {
                                {{varName}} = {{member.Name}};
                                return true;
                            }
                            """);
                    }
                })}}
                {{varName}} = default;
                return false;
            }
            

            public static {{typeName}} Parse(string? text, IFormatProvider? provider = null)
            {
                if (!TryParse(text, provider, out var {{varName}}))
                    throw new ArgumentException($"Could not parse '{text}' to a {{typeName}} value", nameof(text));
                return {{varName}};
            }
            
            public static bool TryParse([NotNullWhen(true)] string? text, IFormatProvider? provider, [MaybeNullWhen(false)] out {typeName} {varName})
            {
                {{(CWA)(w =>
                {
                    // Check names
                    foreach (var member in structInfo.Members)
                    {
                        w.CodeBlock($$"""
                            if (string.Equals(text, {{member.Name}}, StringComparison.OrdinalIgnoreCase))
                            {
                                {{varName}} = {{member.Name}};
                                return true;
                            }
                            """);
                    }
                })}}
       
                if ({{structInfo.UnderlyingType}}.TryParse(text, out {{structInfo.UnderlyingType}} value))
                {
                    {{varName}} = Parse(value);
                    return true;
                }

                {varName} = default;
                return false;
            }
            """);
    }



    private static void Generate(SourceProductionContext ctx, 
        Compilation compilation,
        ImmutableArray<ExtendStructInfo> extendInfos)
    {
        using var writer = new CodeWriter();
        var name = extendInfos.TypeName;

        writer.CodeBlock($$"""
        // <auto-generated/>
        
        namespace {{extendInfos.Namespace}};

        {{extendInfos.Access}} readonly partial struct {{name}} :
            IEqualityOperators<{{name}},{{name}},bool>, IEquatable<{{name}}>,
            IComparisonOperators<{{name}},{{name}},bool>, IComparable<{{name}}>,
            ISpanParsable<{{{name}}}>, IParsable<{{name}}>,
            ISpanFormattable, IFormattable
        {
            {{(CWA)(w => WriteOperators(w, extendInfos))}}
            {{(CWA)(w => WriteStaticBacking(w, extendInfos))}}
        });
        """);


        var sourceCode = writer.ToString();
        ctx.AddSource($"{extendInfos.FQN}.g.cs",
            SourceText.From(sourceCode, Encoding.UTF8));
    }


    private static ExtendStructInfo CreateExtendStructInfo(SourceProductionContext context,
        Compilation compilation,
        StructDeclarationSyntax structDeclaration)
    {
        string fqn;
        string? ns;
        Accessibility access;
        string typeName;
        ITypeSymbol? underlyingType;
        List<ExtendStructMemberInfo> members = new();

        structDeclaration.AttributeLists.First(s =>)


        AttributeSyntax attribute = (context.Node as AttributeSyntax)!;

        var attributeType = context.SemanticModel.GetTypeInfo(attribute, token);
        var mem2 = attributeType.Type.GetMembers();


        var argList = attribute.ArgumentList;

        var children = attribute.ChildNodes();

        var symbol = context.SemanticModel.GetSymbolInfo(attribute, token);

        SemanticModel semanticModel = context.GetSemanticModel(receiverMigrationFunctionAttribute.SyntaxTree);

        foreach (var attributeArgumentSyntax in receiverMigrationFunctionAttribute.ArgumentList.Arguments)
        {
        }

        Debugger.Break();


        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attribute.Parent?.Parent is not StructDeclarationSyntax structDeclaration)
            throw new Exception("Attribute must be on readonly struct def");

        var isReadOnly = structDeclaration.Modifiers.Any(SyntaxKind.ReadOnlyKeyword);
        if (!isReadOnly)
            throw new Exception("Attribute must be on readonly struct def");


        var type = context.SemanticModel.GetDeclaredSymbol(structDeclaration, token) as ITypeSymbol;

        if (type is null)
            throw new InvalidOperationException();

        fqn = type.ToString();
        ns = type.GetNamespace();
        access = type.DeclaredAccessibility;
        typeName = type.Name;
        underlyingType = default;


        return new ExtendStructInfo(fqn, ns, access, typeName, underlyingType, members);
    }


    public static (string Name, string Code) GenerateCode(SourceProductionContext context,
        Compilation compilation,
        StructDeclarationSyntax structDeclaration)
    {
        ExtendStructInfo structInfo = CreateExtendStructInfo(context, compilation, structDeclaration);

        Debugger.Break();

        throw new NotImplementedException();
    }

    public static void ExtendStruct(SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<StructDeclarationSyntax> structDeclarations)
    {
        // Distinct
        var declarations = structDeclarations.Distinct();

        foreach (var declaration in declarations)
        {
            (string name, string code) = GenerateCode(context, compilation, declaration);
            context.AddSource($"{name}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource($"{Code.AttributeFullName}.g.cs",
                SourceText.From(Code.AttributeCode, Encoding.UTF8));
        });

        var structDeclarations = context
            .SyntaxProvider
            .CreateSyntaxProvider(IsAttribute, GetStructDeclaration);

        // Combine
        var compilationValues = context
            .CompilationProvider
            .Combine(structDeclarations.Collect());
        //.Collect()
        //.SelectMany((myObjects, _) => myObjects.Distinct());

        context.RegisterSourceOutput(compilationValues, 
            static (ctx, values) => ExtendStruct(ctx, values.Left, values.Right));
    }
}

public readonly struct ExtendStructMemberInfo : IEquatable<ExtendStructMemberInfo>
{
    public readonly ulong Id;
    public readonly string Name;

    public ExtendStructMemberInfo(ulong id, string name)
    {
        this.Id = id;
        this.Name = name;
    }

    public bool Equals(ExtendStructMemberInfo other)
    {
        return other.Id == this.Id;
    }

    public override bool Equals(object? obj)
    {
        return obj is ExtendStructMemberInfo other && Equals(other);
    }

    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    public override string ToString()
    {
        return $"({Id}) {Name}";
    }
}

public readonly struct ExtendStructInfo : IEquatable<ExtendStructInfo>
{
    public readonly string FQN;
    public readonly string? Namespace;
    public readonly Accessibility Access;
    public readonly string TypeName;
    public readonly ITypeSymbol? UnderlyingType;
    public readonly List<ExtendStructMemberInfo> Members;

    public string VariableName
    {
        get
        {
            var name = this.TypeName.WithNaming(Naming.Camel);
            if (SyntaxFacts.IsValidIdentifier(name))
            {
                return "value";
            }

            return name;
        }
    }

    public ExtendStructInfo(string fqn, string? ns, Accessibility access, string typeName, ITypeSymbol? underlyingType,
        List<ExtendStructMemberInfo> members)
    {
        FQN = fqn;
        Namespace = ns;
        Access = access;
        TypeName = typeName;
        UnderlyingType = underlyingType;
        Members = members;
    }

    public bool Equals(ExtendStructInfo other)
    {
        return string.Equals(FQN, other.FQN);
    }

    public override bool Equals(object? obj)
    {
        return obj is ExtendStructInfo other && Equals(other);
    }

    public override int GetHashCode()
    {
        return FQN.GetHashCode();
    }

    public override string ToString()
    {
        return $"{Namespace} {Access} {TypeName}";
    }
}*/