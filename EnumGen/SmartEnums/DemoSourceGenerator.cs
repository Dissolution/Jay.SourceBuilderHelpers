using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;

namespace Jay.EnumGen.SmartEnums;

[Generator]
public class DemoSourceGenerator : IIncrementalGenerator
{
    private static bool CouldBeEnumerationAsync(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        if (name is not ("EnumGeneration" or "EnumGenerationAttribute"))
            return false;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        return attribute.Parent?.Parent is ClassDeclarationSyntax classDeclaration &&
            IsPartial(classDeclaration);
    }

    internal static bool IsPartial(ClassDeclarationSyntax classDeclarationSyntax)
    {
        return classDeclarationSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private static string? ExtractName(NameSyntax? name)
    {
        return name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }

    private static ITypeSymbol? GetEnumTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return null;

        var type = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;

        if (type is null) return null;
        var isEnum = IsEnumeration(type);
        if (!isEnum) return null;
        return type;
    }

    internal static bool IsEnumeration(ISymbol type)
    {
        foreach (var attr in type.GetAttributes())
        {
            var attrClass = attr.AttributeClass;
            if (attrClass is null) continue;
            if (attrClass.Name == "EnumGenerationAttribute")
            {
                var ns = attrClass.ContainingNamespace;
                if (ns.ToString() == "Jay.EnumGen.SmartEnums")
                    return true;
            }
        }
        return false;
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ITypeSymbol> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty)
            return;

        foreach (var type in enumerations)
        {
            var code = GenerateCode(type);
            var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                ? null
                : $"{type.ContainingNamespace}.";

            context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToString();
        var name = type.Name;
        var items = GetItemNames(type);

        return @$"// <auto-generated />

using System.Collections.Generic;

{(ns is null ? null : $@"namespace {ns}
{{")}
   partial class {name}
   {{
      private static IReadOnlyList<{name}> _items;
      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      private static IReadOnlyList<{name}> GetItems()
      {{
         return new[] {{ {string.Join(", ", items)} }};
      }}
   }}
{(ns is null ? null : @"}
")}";
    }

    private static IEnumerable<string> GetItemNames(ITypeSymbol type)
    {
        return type.GetMembers()
            .Select(m =>
            {
                if (!m.IsStatic ||
                    m.DeclaredAccessibility != Accessibility.Public ||
                    m is not IFieldSymbol field)
                    return null;

                return SymbolEqualityComparer.Default.Equals(field.Type, type)
                    ? field.Name
                    : null;
            })
            .Where(field => field is not null)!;
    }



    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource($"EnumGeneratorAttribute.g.cs",
                SourceText.From(Code.EnumGenerationAttributeCode, Encoding.UTF8));
        });
        
        var classProvider = context.SyntaxProvider
            .CreateSyntaxProvider(), GetExtendStructInfo)
            .Collect()
            .SelectMany((myObjects, _) => myObjects.Distinct());

        context.RegisterSourceOutput(classProvider, Generate);
    }
}