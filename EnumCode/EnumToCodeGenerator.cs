using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Jay.SourceGen.Enums;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Jay.SourceGen.EnumCode;

[Generator]
public class EnumToCodeGenerator : IIncrementalGenerator
{
    private static readonly string EnumToCodeAttributeName = typeof(EnumToCodeAttribute).FullName;

    private static bool IsSyntaxNodeValid(SyntaxNode node, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // All enum declarations
        return node is EnumDeclarationSyntax enumDeclarationSyntax &&
            // Where the enum has at least 1 attribute
            enumDeclarationSyntax.AttributeLists.Count > 0;
    }

    private static EnumDeclarationSyntax? GetEnumDeclaration(GeneratorSyntaxContext context, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // we know the node is a EnumDeclarationSyntax thanks to IsSyntaxTargetForGeneration
        var enumDeclarationSyntax = (EnumDeclarationSyntax)context.Node;

        // loop through all the attributes on the method
        foreach (AttributeListSyntax attributeListSyntax in enumDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            token.ThrowIfCancellationRequested();

            // Get the attribute symbol
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                // failed, ignore
                continue;
            }

            INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
            string fullName = attributeContainingTypeSymbol.ToDisplayString();

            // Is this our EnumToCode Attribute?
            if (fullName == EnumToCodeAttributeName)
            {
                // return the enum
                return enumDeclarationSyntax;
            }
        }

        // we didn't find the attribute we were looking for
        return null;
    }

    private static string GenerateExtensionsClass(EnumCodeInfo enumCodeInfo,
        StringBuilder text)
    {
        const string tab = "    ";  // spaces > tabs, :-P

        text.AppendLine("// <auto-generated/>")
            .AppendLine("using System;")
            .AppendLine()
            .Append("namespace ").Append(enumCodeInfo.Namespace).AppendLine(";")
            .AppendLine()
            .Append("public static partial class ")
            .Append(enumCodeInfo.Name)
            .AppendLine("Extensions")
            .AppendLine("{")
            .Append(tab).Append("public static string ToEnumCode(this ").Append(enumCodeInfo.Name).AppendLine(" value)")
            .Append(tab).Append(tab).AppendLine("=> value switch")
            .Append(tab).Append(tab).AppendLine("{");
        foreach (var (fieldName, code) in enumCodeInfo.MemberNames)
        {
            text.Append(tab).Append(tab).Append(tab)
                .Append(enumCodeInfo.Name)
                .Append('.')
                .Append(fieldName)
                .Append(" => ")
                .Append('"').Append(code).AppendLine("\",");
        }

        text.Append(tab).Append(tab).Append(tab)
            .AppendLine("_ => value.ToString(),")
            .Append(tab).Append(tab).AppendLine("};")
            .AppendLine("}");

        var str = text.ToString();
        text.Clear();
        return str;
    }

    private static void CreateExtensions(Compilation compilation,
        ImmutableArray<EnumDeclarationSyntax> enumDeclarations,
        SourceProductionContext context)
    {
        // Do we have any to create?
        if (enumDeclarations.IsDefaultOrEmpty) return;

        // Cleanup
        IEnumerable<EnumDeclarationSyntax> enums = enumDeclarations.Distinct();

        var enumsToGenerate = GetAllEnumCodeInfo(compilation, enums, context.CancellationToken);
        if (enumsToGenerate.Count > 0)
        {
            var stringBuilder = new StringBuilder();
            foreach (var enumToGenerate in enumsToGenerate)
            {
                var code = GenerateExtensionsClass(enumToGenerate, stringBuilder);
                context.AddSource($"{enumToGenerate.Name}_EnumExtensions.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        }
    }

    private static EnumToCodeAttribute ExtractAttribute(AttributeData attributeData)
    {
        string? code = null;
        Naming naming = Naming.Default;

        // Check the parameters
        var attrArgs = attributeData.NamedArguments;
        foreach (var namedArgument in attrArgs)
        {
            string? key = namedArgument.Key;
            TypedConstant value = namedArgument.Value;
            if (key == "Code")
            {
                if (value.Type is null || value.Type.Name != nameof(String))
                {
                    Debug.WriteLine("Bad Code Type");
                    continue;
                }
                code = value.Value?.ToString();
                break;
            }
            if (key == nameof(Naming))
            {
                if (value.Type is null || value.Type.Name != nameof(Naming))
                {
                    Debug.WriteLine("Bad Naming Type");
                    continue;
                }
                naming = (Naming)value.Value!;
                break;
            }
        }

        return new EnumToCodeAttribute
        {
            Code = code,
            Naming = naming,
        };
    }

    private static List<EnumCodeInfo> GetAllEnumCodeInfo(Compilation compilation,
        IEnumerable<EnumDeclarationSyntax> enumDeclarations, 
        CancellationToken token)
    {
        var enumCodes = new List<EnumCodeInfo>();

        // We want to know about [EnumToCode]
        INamedTypeSymbol? typeEnumToCodeAttribute = compilation.GetTypeByMetadataName(EnumToCodeAttributeName);
        if (typeEnumToCodeAttribute is null)
            return enumCodes;

        // We're also interested in [Flags]
        INamedTypeSymbol? typeFlagsAttribute = compilation.GetTypeByMetadataName("System.FlagsAttribute");

        // Process all enum declarations
        foreach (var enumDeclaration in enumDeclarations)
        {
            token.ThrowIfCancellationRequested();

            SemanticModel semanticModel = compilation.GetSemanticModel(enumDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(enumDeclaration) is not INamedTypeSymbol enumSymbol)
            {
                Debug.WriteLine("Could not find EnumDeclaration as a NamedTypeSymbol in semanticModel");
                continue;
            }

            string enumName = enumSymbol.Name;
            Naming memberNaming = Naming.Default;
            string enumNamespace = enumSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : enumSymbol.ContainingNamespace.ToString();
            var hasFlags = false;

            // Check this enum's attributes
            foreach (AttributeData attributeData in enumSymbol.GetAttributes())
            {
                // If this is [Flags], record it
                if (typeFlagsAttribute is not null && typeFlagsAttribute.Equals(attributeData.AttributeClass, SymbolEqualityComparer.Default))
                {
                    hasFlags = true;
                    continue;
                }

                // Has to be [EnumToCode]
                if (!typeEnumToCodeAttribute.Equals(attributeData.AttributeClass, SymbolEqualityComparer.Default))
                {
                    continue;
                }

                // We have it
                var attr = ExtractAttribute(attributeData);
                if (!string.IsNullOrWhiteSpace(attr.Code))
                {
                    throw new InvalidOperationException("We do not support Code on the Enum level");
                    //enumName = attr.Code!;
                }
                else
                {
                    memberNaming = attr.Naming;
                }

            }

            string fullyQualifiedName = enumSymbol.ToString();
            string underlyingType = enumSymbol.EnumUnderlyingType?.ToString() ?? "int";

            var enumMembers = enumSymbol.GetMembers();
            var memberNames = new List<(string, string)>(enumMembers.Length);
          
            foreach (var member in enumMembers)
            {
                // Has to be a constant field (aka an enum member)
                if (member is not IFieldSymbol field || field.ConstantValue is null)
                {
                    continue;
                }

                string memberName = field.Name;
                string? memberCode = null;
                foreach (var attribute in member.GetAttributes())
                {
                    // We only care about [EnumToCode]
                    if (!typeEnumToCodeAttribute.Equals(attribute.AttributeClass, SymbolEqualityComparer.Default))
                    {
                        continue;
                    }

                    var attr = ExtractAttribute(attribute);
                    if (!string.IsNullOrWhiteSpace(attr.Code))
                    {
                        memberCode = attr.Code!;
                    }
                    else
                    {
                        memberCode = memberName.WithNaming(attr.Naming);
                    }

                    break;
                }

                // If we didn't get a membername, default with Type naming
                if (string.IsNullOrWhiteSpace(memberCode))
                {
                    memberCode = memberName.WithNaming(memberNaming)!;
                }

                memberNames.Add((memberName, memberCode!));
            }

            enumCodes.Add(new EnumCodeInfo(
                name: enumName,
                fullyQualifiedName: fullyQualifiedName,
                ns: enumNamespace,
                underlyingType: underlyingType,
                isPublic: enumSymbol.DeclaredAccessibility == Accessibility.Public,
                hasFlags: hasFlags,
                memberNames: memberNames));
        }

        return enumCodes;
    }

    internal readonly struct EnumCodeInfo
    {
        public readonly string Name;
        public readonly string FullyQualifiedName;
        public readonly string Namespace;
        public readonly bool IsPublic;
        public readonly bool HasFlags;
        public readonly string UnderlyingType;
        public readonly List<(string FieldName, string Code)> MemberNames;

        public EnumCodeInfo(
            string name,
            string ns,
            string fullyQualifiedName,
            string underlyingType,
            bool isPublic,
            List<(string FieldName, string Code)> memberNames,
            bool hasFlags)
        {
            Name = name;
            Namespace = ns;
            UnderlyingType = underlyingType;
            MemberNames = memberNames;
            HasFlags = hasFlags;
            IsPublic = isPublic;
            FullyQualifiedName = fullyQualifiedName;
        }

    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add raw code
        context.RegisterPostInitializationOutput(ctx =>
        {
            //ctx.AddSource("???.g.cs", SourceText.From("CONST", Encoding.UTF8));
        });

        // First cache: all Enum Declarations
        IncrementalValuesProvider<EnumDeclarationSyntax> enumDeclarations
            = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, token) => IsSyntaxNodeValid(node, token),
                    transform: static (ctx, token) => GetEnumDeclaration(ctx, token))
                .Where(static e => e is not null)!;

        // Second cache: All the enum declarations for this compilation
        IncrementalValueProvider<(Compilation Compilation, ImmutableArray<EnumDeclarationSyntax> EnumDeclarations)> compilationEnumDeclarations
            = context.CompilationProvider.Combine(enumDeclarations.Collect());

        // Do the work
        context.RegisterSourceOutput(compilationEnumDeclarations,
            static (ctx, source) => CreateExtensions(source.Compilation, source.EnumDeclarations, ctx));
    }
}